<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>calibration.sub.loglikelihood &mdash; NEDUM-2D for CoCT  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> NEDUM-2D for CoCT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme_link.html">Introducing NEDUM-2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license_rst.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../main_nb.html">Notebook: run model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../calib_nb.html">Notebook: run calibration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guidelines.html">User guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../use_case.html">Use case</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../technical_doc.html">Technical documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input_tables.html">Input tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_bases.html">Data bases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_sets.html">Data sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math_appendix.html">Math appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_ref.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install_help.html">Installation help</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NEDUM-2D for CoCT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>calibration.sub.loglikelihood</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for calibration.sub.loglikelihood</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Oct 20 11:46:13 2020.</span>

<span class="sd">@author: Charlotte Liotta</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>


<div class="viewcode-block" id="LogLikelihoodModel"><a class="viewcode-back" href="../../../api_ref.html#calibration.sub.loglikelihood.LogLikelihoodModel">[docs]</a><span class="k">def</span> <span class="nf">LogLikelihoodModel</span><span class="p">(</span><span class="n">X0</span><span class="p">,</span> <span class="n">Uo2</span><span class="p">,</span> <span class="n">net_income</span><span class="p">,</span> <span class="n">groupLivingSpMatrix</span><span class="p">,</span>
                       <span class="n">dataDwellingSize</span><span class="p">,</span>
                       <span class="n">selectedDwellingSize</span><span class="p">,</span> <span class="n">dataRent</span><span class="p">,</span> <span class="n">selectedRents</span><span class="p">,</span>
                       <span class="n">predictorsAmenitiesMatrix</span><span class="p">,</span>
                       <span class="n">tableRegression</span><span class="p">,</span> <span class="n">variables_regression</span><span class="p">,</span>
                       <span class="n">CalculateDwellingSize</span><span class="p">,</span> <span class="n">ComputeLogLikelihood</span><span class="p">,</span>
                       <span class="n">optionRegression</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute composite log-likelihood for model fit given scanned parameters.</span>

<span class="sd">    This function computes three separate log-likelihoods that capture the fit</span>
<span class="sd">    of the model along distinct data moments. Then, it sums them to give a</span>
<span class="sd">    composite log-likelihood that will be maximized to calibrate the utility</span>
<span class="sd">    function parameters (as part of scanning or smooth optimization process).</span>
<span class="sd">    More precisely, it starts by regressing theoretical values of the log</span>
<span class="sd">    amenity index on observed exogenous dummy amenity variables. The first</span>
<span class="sd">    log-likelihood is computed based on the value of residuals. Then, it</span>
<span class="sd">    defines a second log-likelihood for the fit on income sorting (matching</span>
<span class="sd">    the observed dominant income group with the highest bidding income group).</span>
<span class="sd">    Finally, it gets the residuals from the log-difference between theoretical</span>
<span class="sd">    and observed dwelling sizes, and computes the third log-likelihood from</span>
<span class="sd">    there.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X0 : ndarray(float64)</span>
<span class="sd">        Set of inputs (namely, surplus housing elasticity, basic need in</span>
<span class="sd">        housing, utility levels for income groups 3 and 4) tested for a given</span>
<span class="sd">        iteration</span>
<span class="sd">    Uo2 : int32</span>
<span class="sd">        Target utility level for income group 2</span>
<span class="sd">    net_income : ndarray(float64, ndim=2)</span>
<span class="sd">        Expected annual income net of commuting costs (in rands, for</span>
<span class="sd">        one household), for SP (1,046), by income group excluding the poorest</span>
<span class="sd">        (3)</span>
<span class="sd">    groupLivingSpMatrix : ndarray(bool, ndim=2)</span>
<span class="sd">        Dummy variable indicating, for each income group excluding the poorest</span>
<span class="sd">        (3) whether it is dominant in each SP (1,046)</span>
<span class="sd">    dataDwellingSize : Series</span>
<span class="sd">        Average dwelling size (in mÂ²) for each SP (1,046), from SP data</span>
<span class="sd">    selectedDwellingSize : Series</span>
<span class="sd">        Dummy variable indicating, for each SP (1,046), whether it is selected</span>
<span class="sd">        into the sample used when regressing observed dwelling sizes on their</span>
<span class="sd">        theoretical equivalent</span>
<span class="sd">    dataRent : Series</span>
<span class="sd">        Theoretical average annual rent for formal private housing, computed</span>
<span class="sd">        from data on average land prices, for each SP (1,046)</span>
<span class="sd">    selectedRents : Series</span>
<span class="sd">        Dummy variable indicating, for each SP (1,046), whether it is selected</span>
<span class="sd">        into the sample used when estimating the discrete choice logit model</span>
<span class="sd">        associated with income sorting (identifying observed rents with highest</span>
<span class="sd">        bid-rents from the dominant income group)</span>
<span class="sd">    predictorsAmenitiesMatrix : ndarray(float64, ndim=2)</span>
<span class="sd">        Values of selected exogenous dummy amenity variables (10, including the</span>
<span class="sd">        intercept) in each selected SP (according to selectedRents)</span>
<span class="sd">    tableRegression : DataFrame</span>
<span class="sd">        Values of all exogenous dummy amenity variables (16, excluding the</span>
<span class="sd">        intercept) in each selected SP (according to selectedRents)</span>
<span class="sd">    variables_regression : list</span>
<span class="sd">        List of labels for selected exogenous dummy amenity variables (9,</span>
<span class="sd">        excluding the intercept)</span>
<span class="sd">    CalculateDwellingSize : function</span>
<span class="sd">        Function defining the relationship between rents and dwelling sizes</span>
<span class="sd">        in the formal private sector (see technical documentation)</span>
<span class="sd">    ComputeLogLikelihood : function</span>
<span class="sd">        Log-likelihood function for a lognormal law of mean 0: we will assume</span>
<span class="sd">        that dwelling size and amenity residuals follow such a law</span>
<span class="sd">    optionRegression : int</span>
<span class="sd">        Option to run GLM (instead of OLS) regression for the estimation of</span>
<span class="sd">        exogenous amenity estimates: default is set as zero as GLM is unstable</span>
<span class="sd">    options : dict</span>
<span class="sd">        Dictionary of default options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scoreTotal : float64</span>
<span class="sd">        Value of the composite log-likelihood for the set of parameters scanned</span>
<span class="sd">    scoreAmenities : float64</span>
<span class="sd">        Value of the log-likelihood for the fit on exogenous amenities</span>
<span class="sd">    scoreDwellingSize : float64</span>
<span class="sd">        Value of the log-likelihood for the fit on observed dwelling sizes</span>
<span class="sd">    scoreIncomeSorting : float64</span>
<span class="sd">        Value of the log-likelihood for the fit on observed income sorting</span>
<span class="sd">        (matching observed rents to highest bid-rents from dominant income</span>
<span class="sd">         group)</span>
<span class="sd">    scoreHousing : float64</span>
<span class="sd">        Value of the log-likelihood for the fit on observed housing supply</span>
<span class="sd">        / building density: this is not used in this version of the model as</span>
<span class="sd">        the relation is already used for the calibration of construction</span>
<span class="sd">        function parameters (hence is set equal to zero)</span>
<span class="sd">    parametersAmenities : ndarray(float64)</span>
<span class="sd">        List of estimates for the impact of exogenous (dummy) amenities on the</span>
<span class="sd">        calibrated amenity index (in log-form). In the order: distance to the</span>
<span class="sd">        ocean &lt;2km, distance to the ocean between 2 and 4km, slope between</span>
<span class="sd">        1 and 5%, slope &gt;5%, being located within the airport cone, distance</span>
<span class="sd">        to district parks &lt;2km, distance to biosphere reserve &lt;2km, distance</span>
<span class="sd">        to train station &lt;2km, distance to urban heritage site &lt;2km</span>
<span class="sd">    modelAmenities : regression.linear_model.RegressionResultsWrapper</span>
<span class="sd">        Object summarizing the results of the log-regressions of the</span>
<span class="sd">        theoretical amenity index over observed exogenous amenity dummies</span>
<span class="sd">    parametersHousing : int</span>
<span class="sd">        List of estimates related to the fit of the model on building density</span>
<span class="sd">        / housing supply: this is not included in this version of the model</span>
<span class="sd">        (vector is set equal to zero) as we already exploit this relation to</span>
<span class="sd">        estimate parameters of the construction function (compared to other</span>
<span class="sd">        versions where we use construction costs)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We extract scanned parameters from input vector</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">basicQ</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Uo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Uo2</span><span class="p">,</span> <span class="n">X0</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">X0</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>

    <span class="c1"># %% Error on the amenity index</span>

    <span class="c1"># Theoretical formula for log amenity index (from technical documentation)</span>
    <span class="c1"># Note that we stay under sample selection from selectedRents variable</span>
    <span class="n">logAmenityIndex</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Uo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">**</span> <span class="n">beta</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">net_income</span><span class="p">[:,</span> <span class="n">selectedRents</span><span class="p">]</span>
               <span class="o">-</span> <span class="n">basicQ</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataRent</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="n">selectedRents</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataRent</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="n">selectedRents</span><span class="p">]</span> <span class="o">**</span> <span class="n">beta</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="c1"># We select values for dominant income groups only and flatten the array:</span>
    <span class="c1"># this allows to select the appropriate net income and utility to identify</span>
    <span class="c1"># the regression</span>
    <span class="n">logAmenityIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
        <span class="n">logAmenityIndex</span> <span class="o">*</span> <span class="n">groupLivingSpMatrix</span><span class="p">[:,</span> <span class="n">selectedRents</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># logAmenityIndex[np.abs(logAmenityIndex.imag) &gt; 0] = np.nan</span>
    <span class="c1"># logAmenityIndex[logAmenityIndex == -np.inf] = np.nan</span>

    <span class="c1"># We get residuals for the regression of log amenity index on exogenous</span>
    <span class="c1"># dummy variables.</span>
    <span class="c1"># Note that we identify dummies with logs of original amenity values</span>
    <span class="c1"># (normalized to take values between 1 and e): see technical documentation</span>

    <span class="c1"># OLS estimation</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">optionRegression</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">predictorsAmenitiesMatrix</span>  <span class="c1"># [~np.isnan(logAmenityIndex), :]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">logAmenityIndex</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">logAmenityIndex</span><span class="p">)])</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># parametersAmenities, residuals, rank, s = np.linalg.lstsq(A, y,</span>
        <span class="c1">#                                                           rcond=None)</span>
        <span class="c1"># res = scipy.optimize.lsq_linear(A, y)</span>
        <span class="c1"># parametersAmenities = res.x</span>
        <span class="c1"># residuals = res.fun</span>
        <span class="n">modelSpecification</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span>
        <span class="n">modelAmenities</span> <span class="o">=</span> <span class="n">modelSpecification</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">parametersAmenities</span> <span class="o">=</span> <span class="n">modelAmenities</span><span class="o">.</span><span class="n">params</span>
        <span class="n">errorAmenities</span> <span class="o">=</span> <span class="n">modelAmenities</span><span class="o">.</span><span class="n">resid_pearson</span>
        <span class="c1"># errorAmenities = y - np.nansum(A * parametersAmenities, 1)</span>
        <span class="c1"># modelAmenities = 0</span>

    <span class="c1"># GLM estimation (unstable)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">optionRegression</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">residu</span> <span class="o">=</span> <span class="n">logAmenityIndex</span><span class="o">.</span><span class="n">real</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">predictorsAmenitiesMatrix</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">logAmenityIndex</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">logAmenityIndex</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">logAmenityIndex</span><span class="p">)])</span><span class="o">.</span><span class="n">real</span>
        <span class="n">parametersAmenities</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                                                                  <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">modelSpecification</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span>
            <span class="n">residu</span><span class="p">,</span> <span class="n">tableRegression</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">variables_regression</span><span class="p">])</span>
        <span class="n">modelAmenities</span> <span class="o">=</span> <span class="n">modelSpecification</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">errorAmenities</span> <span class="o">=</span> <span class="n">modelAmenities</span><span class="o">.</span><span class="n">resid_pearson</span>

    <span class="c1"># Residuals follow a log-normal law, hence the associated log-likelihood</span>
    <span class="c1"># from ComputeLogLikelihood function (see math appendix)</span>
    <span class="n">scoreAmenities</span> <span class="o">=</span> <span class="n">ComputeLogLikelihood</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">errorAmenities</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">errorAmenities</span><span class="p">))),</span>
        <span class="n">errorAmenities</span><span class="p">)</span>

    <span class="c1"># %% Error on income sorting</span>

    <span class="c1"># We start by defining input variables</span>
    <span class="n">utility_over_amenity</span> <span class="o">=</span> <span class="n">Uo</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logAmenityIndex</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">net_income_select</span> <span class="o">=</span> <span class="n">net_income</span><span class="p">[:,</span> <span class="n">selectedRents</span><span class="p">]</span>

    <span class="c1"># We then apply formula from technical documentation</span>
    <span class="n">bidRents</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">net_income_select</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">**</span> <span class="n">beta</span><span class="p">)</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">utility_over_amenity</span>
            <span class="o">-</span> <span class="n">basicQ</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">**</span> <span class="n">beta</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># We select SPs where at least some income group makes a positive bid</span>
    <span class="n">selectedBidRents</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">bidRents</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># We again select the dominant income group</span>
    <span class="n">incomeGroupSelectedRents</span> <span class="o">=</span> <span class="n">groupLivingSpMatrix</span><span class="p">[:,</span> <span class="n">selectedRents</span><span class="p">]</span>

    <span class="c1"># We create a function for the minus log-likelihood of income sorting:</span>
    <span class="c1"># see technical documentation for math formula. We consider minus form</span>
    <span class="c1"># to be able to use scipy.optimize.minimize() function. We will then return</span>
    <span class="c1"># minus form for the minimum obtained to recover the maximum value of the</span>
    <span class="c1"># log-likelihood (across scale factors).</span>

    <span class="n">minusLogLikIncomeSorting</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">lambda</span> <span class="n">scaleParam</span><span class="p">:</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
                <span class="n">bidRents</span><span class="p">[:,</span> <span class="n">selectedBidRents</span><span class="p">]</span> <span class="o">/</span> <span class="n">scaleParam</span>
                <span class="o">*</span> <span class="n">incomeGroupSelectedRents</span><span class="p">[:,</span> <span class="n">selectedBidRents</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bidRents</span><span class="p">[:,</span> <span class="n">selectedBidRents</span><span class="p">]</span> <span class="o">/</span> <span class="n">scaleParam</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">)))</span>
            <span class="p">)</span>

    <span class="c1"># Actually, since we cannot identify the gravity parameter, we pin it at</span>
    <span class="c1"># 10, which allows to get a score of the same order of magnitude as for</span>
    <span class="c1"># the fit on amenities. It is also a realistic and conservative guess:</span>
    <span class="c1"># the order of magnitude is the same as for the gravity parameter from the</span>
    <span class="c1"># commuting choice model, and it is low enough (given the function</span>
    <span class="c1"># definition, the higher the parameter, the smaller the output).</span>
    <span class="c1"># Also note that the improvement is marginal for higher orders of magnitude</span>

    <span class="c1"># We keep the optimization in comments for reference, in case we want to be</span>
    <span class="c1"># less conservative about the value of the log-likelihood</span>

    <span class="n">scoreIncomeSorting</span> <span class="o">=</span> <span class="o">-</span> <span class="n">minusLogLikIncomeSorting</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># bnds = {(0, 10**10)}</span>
    <span class="c1"># initScale = 10**5</span>
    <span class="c1"># res = scipy.optimize.minimize(</span>
    <span class="c1">#     minusLogLikIncomeSorting, initScale, bounds=bnds,</span>
    <span class="c1">#     options={&#39;maxiter&#39;: 100, &#39;disp&#39;: False})</span>
    <span class="c1"># optiminusLogLikIncomeSorting = res.fun</span>
    <span class="c1"># exitFlag = res.success</span>
    <span class="c1"># print(exitFlag)</span>

    <span class="c1"># %% Error on dwelling sizes</span>

    <span class="c1"># We get theoretical values for market rents that we identify to highest</span>
    <span class="c1"># bid-rents from dominant income group</span>
    <span class="c1"># NB: As bid rents are already defined for sample of SPs selected under</span>
    <span class="c1"># selectedRents, we need to take the subsection</span>
    <span class="c1"># selectedDwellingSize[selectedRents] to operate another selection based on</span>
    <span class="c1"># selectedDwellingSize while respecting array dimensions</span>
    <span class="n">simulatedRents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
        <span class="n">bidRents</span><span class="p">[:,</span> <span class="n">selectedDwellingSize</span><span class="p">[</span><span class="n">selectedRents</span><span class="p">]]</span>
        <span class="o">*</span> <span class="n">groupLivingSpMatrix</span><span class="p">[:,</span> <span class="n">selectedDwellingSize</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># We get theoretical values for dwelling size based on pre-defined function</span>
    <span class="c1"># (see technical documentation for math formula), leveraging the above</span>
    <span class="c1"># definition of simulatedRents</span>
    <span class="n">dwellingSize</span> <span class="o">=</span> <span class="n">CalculateDwellingSize</span><span class="p">(</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">basicQ</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">net_income</span><span class="p">[:,</span> <span class="n">selectedDwellingSize</span><span class="p">]</span>
                  <span class="o">*</span> <span class="n">groupLivingSpMatrix</span><span class="p">[:,</span> <span class="n">selectedDwellingSize</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">simulatedRents</span><span class="p">)</span>

    <span class="c1"># The (log) error on observed dwelling sizes is directly obtain by taking</span>
    <span class="c1"># the log-difference with the theoretical counterpart (staying under the</span>
    <span class="c1"># same sample selection)</span>
    <span class="n">errorDwellingSize</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dwellingSize</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dataDwellingSize</span><span class="p">[</span><span class="n">selectedDwellingSize</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="c1"># Residuals follow a log-normal law, hence the associated log-likelihood</span>
    <span class="c1"># from ComputeLogLikelihood function (see math appendix)</span>
    <span class="n">scoreDwellingSize</span> <span class="o">=</span> <span class="n">ComputeLogLikelihood</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">errorDwellingSize</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">errorDwellingSize</span><span class="p">))),</span>
        <span class="n">errorDwellingSize</span><span class="p">)</span>

    <span class="c1"># %% Total</span>

    <span class="c1"># The sum of logs is the same as the log of a product, hence we can define</span>
    <span class="c1"># our composite log-likelihood function as the sum of our separate</span>
    <span class="c1"># log-likelihoods</span>

    <span class="n">scoreTotal</span> <span class="o">=</span> <span class="n">scoreAmenities</span> <span class="o">+</span> <span class="n">scoreDwellingSize</span> <span class="o">+</span> <span class="n">scoreIncomeSorting</span>
    <span class="c1"># scoreTotal = scoreAmenities</span>

    <span class="c1"># We may also include a measure of the fit for housing supply / household</span>
    <span class="c1"># density, which has not been retained in this version of the model, as</span>
    <span class="c1"># the underlying relation is already used to calibrate parameters of the</span>
    <span class="c1"># construction function.</span>
    <span class="c1"># NB: We still define the variables that we set equal to zero to serve as</span>
    <span class="c1"># placeholders</span>
    <span class="n">scoreHousing</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">parametersHousing</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">scoreTotal</span><span class="p">,</span> <span class="n">scoreAmenities</span><span class="p">,</span> <span class="n">scoreDwellingSize</span><span class="p">,</span> <span class="n">scoreIncomeSorting</span><span class="p">,</span>
            <span class="n">scoreHousing</span><span class="p">,</span> <span class="n">parametersAmenities</span><span class="p">,</span> <span class="n">modelAmenities</span><span class="p">,</span>
            <span class="n">parametersHousing</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Thomas Monnier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>